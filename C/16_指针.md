指针中存储另外一个内存单元

指针的内存单元是一个字节

指针类型决定了指针进行解引用操作时，能够访问空间的大小

int *p  能够访问4个字节

char *p  能够访问1个字节

double *p  能够访问8个字节

```c
int main()
{
   int a = 10;
   int *pa = &a;
   char *pc = &a;
   printf("%p\n", pa);
   printf("%p\n", pa + 1); // 整形指针加1，内存地址加4
   printf("%p\n", pc);
   printf("%p\n", pc + 1); // 字符类型指针加1，内存地址加4
   return 0;
}
```

野指针：指针指向的位置是不可知的，随机的不明确的

会导致生成野指针的方式

1. 指针未初始化
2. 指针越界访问
3. 指针指向的内存空间释放了

```c
1.指针未初始化
int main()
{
   int a;  // 局部变脸不初始化，默认是随机值
   int *p; // 局部的指针变量，就是初始化随机值
   *p = 20;
   return 0;
}

2.指针越界访问
int main(){
   int arr[10] = {0};
   int *p = arr;
   int i = 0;
   for (i=0;i<12;i++)
   {
      p++;
   }
   return 0;
}
```

如何避免野指针：

1. 指针初始化
2. 指针越界
3. 指针指向的空间释放
4. 指针使用之间检查有效性

```c
int main(){
    int *p = NULL; // 用来初始化指针，给指针赋值

    // 指针不想使用时可以定义为空值
    p = NULL;
    
    // 使用指针前判断是否为空
    if (p!=NULL)
    {
        *p = 20;
    }
}
```

利用指针加法遍历打印数组

```c
int main()
{
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int i = 0;
    int sz = sizeof(arr) / sizeof(arr[0]);
    int *p = arr;
    for (i = 0; i < sz; i++)
    {
        printf("%d", *p);
        p = p + 1;
    }
}
```

```c
int main()
{
#define N_VALUES 5
    float values[N_VALUES];
    float *vp;
    for (vp = values; vp < &values[N_VALUES];)
    {
        *vp++ = 0;
    }
}
```

指针减去指针得到的是中间元素的个数（两个指针同一个空间区操作相减）

大地址减去小地址

```c
int main()
{
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    printf("%d\n", &arr[9] - &arr[0]);
    return 0;
}
```

使用指针相减的特性实现len()函数

```c
int my_strlen(char *str)
{
    char *start = str;
    char *end = str;
    while (*end != '\0')
    {
        end++;
    }
    return end - start;
}
int main()
{
    char arr[] = "bit";
    int len = my_strlen(arr);
    printf("%d\n", len);
    return 0;
}
```

C语言指针标准规定：允许指向数组元素的指针最后一个元素后面的那个内存地址的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较