### 事务隔离

A教室和B教室中间有一道墙，这道墙可以很厚也可以很薄，这就是事务的隔离级别

查看当前隔离级别

```sql
select @@transaction_isolation;
```

验证：read uncommitted

设置隔离级别

```sql
set global transaction isolation level read uncommitted;
```

事务与事务间的隔离级别有哪些，四个级别

> 读未提交：read uncommitted（最低的隔离级别）
>
> 读已提交：read committed
>
> 可重复读：repeatable read
>
> 序列化：serializable （最高的隔离级别）

### 读未提交：

事务A可以读取到事务B未提交的数据

这种隔离级别存在的问题就是脏读现象（Dirty Read）

脏读：读到了脏数据称之为脏读

这种级别一般都是理论上的，大多是数据库隔离级别都是二档起步

### 读已提交：

事务A只能读取到事务B提交之后的数据

这种隔离级别解决了脏读现象

这种级别存在的问题：不可重复读取数据

在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读取到二点数据是4条，3不等于4，称之为不可重复读取

这种隔离级别是比较真实的数据，每一次读到的数据都绝对真实

### 可重复读：

（只要自己的事务未结束，提交之后也读不到，读取的永远都是刚开始事务的数据）

事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的，即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读取

可重复读解决了不可重复读取数据的问题，

可重复读存在的问题是：幻影，每一次读取到的数据都是幻想，不够真实

mysql中默认的隔离级别是可重复读

### 序列化：

 最高隔离级别，效率最低，解决了所有问题，表示了事务排队，不能并发

每次只能有一个用户操作，事务同步

每一次读取到的数据都是最真实的，并且效率是最低的

