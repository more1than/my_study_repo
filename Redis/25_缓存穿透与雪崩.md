## Redis缓存穿透和雪崩

## 缓存穿透（缓存中查不到）

用户要查询数据，但发现redis内存数据库中没有，也就是缓存没有命中，于是向持久层数据库来查询，发现数据库中也没有，于是查询失败，当用户多的时候，缓存都没有命中，类似于秒杀机制，于是请求都压到了持久化数据库，给持久化数据库造成了很大的压力。

### 解决方案

### 1.布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力

### 2.缓存空对象

如果缓存没有被命中，即使返回的空对象也将其缓存起来，同时设置一个过期时间，再访问这个数据将会从缓存中取出，保护了后端的数据源

### 但是缓存空对象会出现两个问题

如果控制能够被缓存，就意味着缓存需要更多的空间存储更多的键

即使对空值设置了过期时间，还会造成存储层和缓存层的时间不一致



## 缓存击穿（查询量太大，缓存过期）

一个非常热门的点，一直扛着超大的并发，大并发几种对一个点进行访问，当key失效的瞬间，持续的大并发就突破缓存直接请求到数据库

### 解决方案

热点数据不过期

加互斥锁：保证只有一个线程交互持久化数据库，其余进行等待



## 缓存雪崩

在某一时间，缓存其中过期失效，Redis宕机（停电）

双十一：停掉一些服务，保证主要服务的高可用

数据预热：在正式部署之前将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀





